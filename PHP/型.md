## 型の始まり
**コンピュータの中でデータは１か０（ライトのオン・オフ）かで表現されている**  
データが「どういう種類の値か」を区別するための情報として「型」が誕生した

### オン・オフで自然数をどう表現する？
実際のコンピュータでは２進数で表現されている

### 型は何のために生まれたのか？
**内部データの２進数の値に対して、どういう種類の値かを示すのが「型」**  
型がないと、２進数の値を整数として扱ったら良いか、少数として扱ったら良いか、文字列として扱ったらいいかがわからない

### 型の発展①仕様としての型
**型は値の種類を示すためのものだったが、いろいろなことに応用されるようになった**

- 仕様としての型
```php
function sum(int $a, int $b): int { // 関数の引数や、戻り値に値を指定できる
  return $a + $b
}
```

システムの安全性を高めるために型はよく使われる。

### ②動的型付け
**変数などの値について型を明示せず、実行時にプログラムが自動で型を判定すること**

動的型付けは柔軟性がメリットだが、型チェックによるバグの発見がしにくくなるというデメリットもある。  
phpはzbalという動的型付け

## PHPの型①整数

## 論理型
**論理型はtrue(真)かfalse(偽)のどちらかを表す真偽値**
- 初期化には定数trueまたはfalseを指定。両方とも大文字小文字には依存しない
```
var_dump(true); //bool(true)
var_dump(false); //bool(false)
```
- if文など、論理型を必要とする場合には値は自動的に変換される
  - 以下はfalseと判定される
```
・false(論理型)　　・"0"(文字列のゼロ)
・0(整数型)　・[](要素がゼロの配列)
・0.0(不動小数点型)　・null
・""(空の文字列)　・空のタグから作成されたSimpleXMLオブジェクト
```
- ifの判定は真偽値で行われるため重要

## 配列
**複数の値をまとめて保持するためのもの**
- PHPの内部では配列と連想配列は区別されていない
```php
$array1 = ['a', 'b'];
$array2 = [
    0 => 'a',
    1 => 'b',
];
var_dump($array1 === $array2); //true
```

## null
**nullはある変数が値を持たないことを表す特別な型**
- 以下の場合はnullになる
  - 定数nullが代入されている場合
  - まだ何も代入され値ない場合
  - unset()されている場合
- nullと未定義は違うので注意
```php
$a = null;
var_dump($a); //NULL
var_dump($b); //Warning:Undefined variable $b.Null
```

## リソース
**リソースは外部リソースへのリファレンスを保持しているデータ型**
```php
$fp = fopen("test.txt", "W"); // 外部ファイルを書き込む
echo gettype($fp) //resource
fclose($fp); // ファイルを閉じる
```
- リソース型を使うときに大事なのは、異常系を正しく扱えること

## オブジェクト
**オブジェクトはクラスをnew命令によりインスタンス化したもの**
```php
class Member
{
  function getNaem()
  {
    echo '名前を返します'
  }
}

$member = new Member;
echo gettype($member); // object
```

## コールバック
**コールバックは「関数を引数で取る関数のための擬似的な型」。呼び出し可能な関数をチェックする**
```php
$triple = function ($int) {
  return $int * 3;
};

$numbers = array_map($triple, [1, 2, 3]);

var_dump(implode('', $numbers)); // string(11)"369"
var_dump(is_callable($triple)); // bool(true)
```
- 引数として取れる関数のことをコールバック関数という

## Iterable
**Iterableはforeachで繰り返しができる変数の型**
```php
var_dump(is_iterable([1, 2, 3])); // bool(true)
var_dump(is_iterable(1)); // bool(flase)
